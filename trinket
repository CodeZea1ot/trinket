#!/usr/bin/env bash
set -e

# Defaults
DIR="."
PORT=8000
HOST="localhost"
HTTPS=false
BROWSER=false
WATCH=false
QRCODE=false

CERT_DIR="$HOME/.local/share/mkcert"
CERT="$CERT_DIR/localhost.pem"
KEY="$CERT_DIR/localhost-key.pem"

usage() {
  cat <<EOF
Usage: trinket [options] [directory] [port]

Start a simple HTTP/HTTPS server using Python.

Options:
  -s, --https       Use HTTPS with mkcert (localhost only by default)
  -b, --browser     Automatically open browser
  -H, --host        Host to bind to (default: localhost)
  -w, --watch       Watch files and auto-reload browser
  -Q, --qrcode      Render site address as a QR code
  -h, --help        Show this help message

Arguments:
  directory         Directory to serve (default: current directory)
  port              Port number (default: 8000 HTTP, 8443 HTTPS)

Examples:
  trinket
  trinket public
  trinket public 3000
  trinket -s
  trinket --https
  trinket -s public 8443
  trinket public -b
  trinket -H 0.0.0.0 -s
  trinket public --watch
EOF
}

# --- Parse options ---
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--https)
      HTTPS=true
      shift
      ;;
    -b|--browser)
      BROWSER=true
      shift
      ;;
    -H|--host)
      HOST="$2"
      shift 2
      ;;
    -w|--watch)
      WATCH=true
      shift
      ;;
    -Q|--qrcode)
      QRCODE=true
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --) # end of options
      shift
      break
      ;;
    -*)
      echo "Unknown option: $1"
      usage
      exit 1
      ;;
    *)  # positional argument
      POSITIONAL+=("$1")
      shift
      ;;
  esac
done

set -- "${POSITIONAL[@]}"

[[ -n "$1" ]] && DIR="$1"
[[ -n "$2" ]] && PORT="$2"

if $HTTPS && [[ "$PORT" == 8000 ]]; then
  PORT=8443
fi

if [[ ! -d "$DIR" ]]; then
  echo "Error: directory '$DIR' does not exist"
  exit 1
fi

ORIGINAL_PORT=$PORT
while command -v lsof >/dev/null 2>&1 && lsof -i ":$PORT" >/dev/null 2>&1; do
  PORT=$((PORT + 1))
done

if [[ "$PORT" != "$ORIGINAL_PORT" ]]; then
  echo "Requested port $ORIGINAL_PORT is in use. Using alternative port $PORT."
fi

if $HTTPS; then
  if ! command -v mkcert >/dev/null 2>&1; then
    echo "Error: mkcert is not installed" >&2
    exit 1
  fi

  mkcert -install >/dev/null 2>&1 || true

  if [[ "$HOST" == "0.0.0.0" ]]; then
    LAN_IP=$(ip route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++){if($i=="src"){print $(i+1); exit}}}')
    HOST="${LAN_IP:-localhost}"
  fi

  mkdir -p "$CERT_DIR"
  mkcert -cert-file "$CERT" -key-file "$KEY" localhost 127.0.0.1 ::1 "$HOST"
fi

export TRINKET_HOST="$HOST"
export TRINKET_PORT="$PORT"
export TRINKET_WATCH="$WATCH"
export TRINKET_HTTPS="$HTTPS"
export TRINKET_CERT="$CERT"
export TRINKET_KEY="$KEY"

URL="$([[ $HTTPS == true ]] && echo https://$HOST:$PORT || echo http://$HOST:$PORT)"
echo "Serving $([[ $HTTPS == true ]] && echo HTTPS || echo HTTP) '$DIR' at $URL"

cd "$DIR"

if $BROWSER && command -v xdg-open >/dev/null 2>&1; then
  xdg-open "$URL" >/dev/null 2>&1 &
fi

if [[ $QRCODE == true ]]; then
  if command -v qrterminal >/dev/null 2>&1; then
    echo "$URL" | qrterminal
  elif command -v qrencode >/dev/null 2>&1; then
      qrencode -t ANSIUTF8 "$URL"
  else
    echo "Error: dependency not found for QR code generation; skipping QR code output." >&2
  fi
fi


python3 - <<'EOF'
import os
import http.server
import socketserver
import ssl
import threading
import time
import io
import re

HOST = os.environ["TRINKET_HOST"]
PORT = int(os.environ["TRINKET_PORT"])
WATCH = os.environ["TRINKET_WATCH"] == "true"
HTTPS = os.environ["TRINKET_HTTPS"] == "true"
CERT = os.environ["TRINKET_CERT"]
KEY = os.environ["TRINKET_KEY"]

reload_pending = False

RELOAD_SCRIPT = b"""
<script>
(() => {
  async function poll() {
    try {
      const res = await fetch('/__reload');
      if (res.status === 205) location.reload();
    } catch (e) {}
    setTimeout(poll, 500);
  }
  poll();
})();
</script>
"""

CSS_RE = re.compile(rb'href=["\']([^"\']+\\.css)["\']')

def bust_css(html: bytes) -> bytes:
    ts = str(int(time.time())).encode()
    def repl(m):
        href = m.group(1)
        sep = b"&" if b"?" in href else b"?"
        return b'href="' + href + sep + b'v=' + ts + b'"'
    return CSS_RE.sub(repl, html)

SCRIPT_RE = re.compile(rb'src=["\']([^"\']+\\.js)["\']')

def bust_js(html: bytes) -> bytes:
    ts = str(int(time.time())).encode()
    def repl(m):
        src = m.group(1)
        sep = b"&" if b"?" in src else b"?"
        return b'src="' + src + sep + b'v=' + ts + b'"'
    return SCRIPT_RE.sub(repl, html)


class Handler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header("Cache-Control", "no-store")
        super().end_headers()

    def do_GET(self):
        global reload_pending
        if self.path == "/__reload":
            if WATCH and reload_pending:
                self.send_response(205)
                self.end_headers()
                reload_pending = False
            else:
                self.send_response(204)
                self.end_headers()
            return

        if self.path == "/":
            self.path = "/index.html"

        super().do_GET()

    def send_head(self):
        # Normalize directory requests to index.html
        if self.path.endswith("/"):
            self.path = self.path + "index.html"
            
        path = self.translate_path(self.path)
        if path.endswith(".html") and os.path.exists(path):
            with open(path, "rb") as f:
                content = f.read()

            if WATCH:
                content = bust_css(content)
                content = bust_js(content)
                content = content.replace(b"</body>", RELOAD_SCRIPT + b"</body>")

            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.send_header("Content-Length", str(len(content)))
            self.end_headers()
            return io.BytesIO(content)

        return super().send_head()

def watch_files(root):
    global reload_pending
    print("[watch] Watch mode enabled")
    mtimes = {}
    while True:
        changed = False
        for dirpath, _, files in os.walk(root):
            for f in files:
                path = os.path.join(dirpath, f)
                try:
                    m = os.path.getmtime(path)
                except FileNotFoundError:
                    continue
                if mtimes.get(path) != m:
                    mtimes[path] = m
                    changed = True
                    print(f"[watch] File changed: {f}")
        if changed:
            reload_pending = True
            print("[watch] Reloading clients...")
        time.sleep(0.5)

class ReusableTCPServer(socketserver.ThreadingTCPServer):
    allow_reuse_address = True

httpd = ReusableTCPServer((HOST, PORT), Handler)

if HTTPS:
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    ctx.load_cert_chain(CERT, KEY)
    httpd.socket = ctx.wrap_socket(httpd.socket, server_side=True)

if WATCH:
    threading.Thread(target=watch_files, args=(os.getcwd(),), daemon=True).start()

print(f"Serving on {'https' if HTTPS else 'http'}://{HOST}:{PORT}")
try:
    httpd.serve_forever()
except KeyboardInterrupt:
    print("\nShutting down server...")
    httpd.shutdown()
    httpd.server_close()
EOF
